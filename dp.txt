动态规划要点：
1、选择a与不选择a: dp[i] = f(不选择a时的dp[i],选择a时的dp[i])
其中f：求两者最大值、两者最小值、两者和等等。
其中i：表示使用a组成的目标值。
其中a：表示计算结果可选的元素。每一个都要做一次选择和不选择的计算。
其中dp[i]：表示中间/最终结果，选择哪些a，a的组合数，最少/最多的a数量。

动态规划问题的一般性描述：
假设:
1、集合A有若干个元素，A = {a1, a2, a3, ..., an}。每个元素有若干属性。
2、从集合A中选择若干个元素构成一个子集合，根据子集合的所有元素的某一属性计算属性值t，要求t小于/等于目标值T。
求：
1、有多少个满足要求的子集合（组合数）？
2、每个满足的子集合，根据子集合的所有元素的另外一个属性计算属性值v，选择属性值v最大或者最小的子集合，其对应的属性值是多少？
3、根据要求2选出的子集合，包含多少个元素？
4、根据要求2选出的子集合，包含哪些元素？
解题思路：
1、遍历集合A的每个元素。
2、根据是否选择当前元素，计算属性值从0到目标值T的问题解。
3、最终结果取目标值T的问题解。
额外要求：
1、每个子集合中，每个元素重复次数无限制。（从0到T计算问题解）
2、每个子集合中，每个元素只能出现一次。（从T到0计算问题解）
3、每个子集合中，每个元素可以出现n次。（从T到0计算问题解，每个问题解，计算选择或者不选择0到n个当前元素）

伪代码：
1、
for (each a in A) {
	for (t from a.t up to T) {
		f(t) = g(q(t), h(t,a.t));
	}
}

2、
for (each a in A) {
	for (t from T down to a.t) {
		f(t) = g(q(t), h(t,a.t));
	}
}

3、
for (each a in A) {
	for (t from T down to a.t) {
		for (n from 0 up to count of a)
			if (t < n*a.t) break;
			f(t) = g(q(t), h(t,n*a.t));
	}
}
其中：
f(t)表示子集合属性值为t时的问题解。最终问题解为f(T)。
q(t)表示没有将元素a加入子集合时，子集合属性值为t时的问题解。
h(t,a.t)表示将元素a加入子集合时，子集合属性值为t时的问题解。
h(t,n*a.t)表示将n个元素a加入子集合时，子集合属性值为t时的问题解。
g表示q与h的关系。选择其一个或者同时选择两者，取决于问题解。
